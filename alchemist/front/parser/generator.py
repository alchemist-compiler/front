# This file is part of the Alchemist front-end libraries
# Copyright (C) 2023  Natan Junges <natanajunges@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# The code generated by this library is also under the GNU General Public
# License.

from typing import Union
from collections.abc import Sequence

RuleTemplate = Union[Sequence["RuleTemplate"], "Rule", str]


class Rule:
    @staticmethod
    def get(arg: RuleTemplate) -> "Rule":
        if isinstance(arg, tuple):
            return Group(arg)

        if isinstance(arg, list):
            return Optional(arg)

        if not isinstance(arg, Rule):
            return Term(arg)

        return arg

    @staticmethod
    def filter(args: Sequence[RuleTemplate]) -> list["Rule"]:
        ret = [Rule.get(arg) for arg in args if not isinstance(arg, Switch) or
               arg.enabled]
        ret = [arg for arg in ret if isinstance(arg, Term) or
               len(arg.args.args if isinstance(arg.args, Group) else arg.args)
               > 0]
        return ret

    @staticmethod
    def indent(level: int) -> str:
        return f"\n{'    ' * level}"

    @staticmethod
    def paths(level: int) -> str:
        return f"paths{str(level)}"

    def __init__(self, args: Union[list["Rule"], "Group"]):
        self.args: Union[list[Rule], Group] = args

    def __call__(self, indent_level: int, paths_level: int) -> str:
        raise NotImplementedError()


class Group(Rule):
    def __init__(self, args: Sequence[RuleTemplate]):
        super().__init__(Rule.filter(args))
        i = 0

        while i < len(self.args):
            if isinstance(self.args[i], Group):
                group = self.args[i].args
                self.args = self.args[:i] + group + self.args[i + 1:]
                i += len(group)
            else:
                i += 1

    def __call__(self, indent_level: int, paths_level: int) -> str:
        ret = ""

        for arg in self.args:
            ret += arg(indent_level, paths_level)

        return ret


class Optional(Rule):
    def __init__(self, args: list[RuleTemplate]):
        super().__init__(Group(args))

        if (len(self.args.args) == 1 and
                isinstance(self.args.args[0], Optional)):
            self.args = self.args.args[0].args

    def __call__(self, indent_level: int, paths_level: int) -> str:
        ret = "\n"
        ret += f"{Rule.indent(indent_level)}try:  # optional"
        ret += f"{Rule.indent(indent_level + 1)}{Rule.paths(paths_level + 1)} = {Rule.paths(paths_level)}"
        ret += self.args(indent_level + 1, paths_level + 1)
        ret += f"{Rule.indent(indent_level + 1)}{Rule.paths(paths_level)} |= {Rule.paths(paths_level + 1)}"
        ret += f"{Rule.indent(indent_level)}except (CompilerSyntaxError, CompilerEOIError):"
        ret += f"{Rule.indent(indent_level + 1)}pass"
        ret += "\n"
        return ret


class Switch(Rule):
    enabled: bool = False

    def __init__(self, *args: RuleTemplate):
        if self.enabled:
            super().__init__(Group(args))

    def __call__(self, indent_level: int, paths_level: int) -> str:
        return self.args(indent_level, paths_level)


class repeat(Rule):
    def __init__(self, *args: RuleTemplate):
        super().__init__(Group(args))

        if len(self.args.args) == 1 and isinstance(self.args.args[0], repeat):
            self.args = self.args.args[0].args

    def __call__(self, indent_level: int, paths_level: int) -> str:
        ret = "\n"
        ret += f"{Rule.indent(indent_level)}# begin repeat"
        ret += f"{Rule.indent(indent_level)}{Rule.paths(paths_level + 1)} = {Rule.paths(paths_level)}"
        ret += "\n"
        ret += f"{Rule.indent(indent_level)}while True:"
        ret += f"{Rule.indent(indent_level + 1)}try:"
        ret += self.args(indent_level + 2, paths_level + 1)
        ret += f"{Rule.indent(indent_level + 2)}{Rule.paths(paths_level)} |= {Rule.paths(paths_level + 1)}"
        ret += f"{Rule.indent(indent_level + 1)}except (CompilerSyntaxError, CompilerEOIError):"
        ret += f"{Rule.indent(indent_level + 2)}break"
        ret += "\n"
        ret += f"{Rule.indent(indent_level)}# end repeat"
        ret += "\n"
        return ret


class oneof(Rule):
    def __init__(self, *args: RuleTemplate):
        super().__init__(Rule.filter(args))
        i = 0

        while i < len(self.args):
            if isinstance(self.args[i], oneof):
                options = self.args[i].args
                self.args = self.args[:i] + options + self.args[i + 1:]
                i += len(options)
            else:
                i += 1

    def __call__(self, indent_level: int, paths_level: int) -> str:
        if len(self.args) == 1:
            return self.args[0](indent_level, paths_level)

        ret = "\n"
        ret += f"{Rule.indent(indent_level)}# begin oneof"
        ret += f"{Rule.indent(indent_level)}{Rule.paths(paths_level + 1)} = set()"

        for i, arg in enumerate(self.args):
            ret += "\n"
            ret += f"{Rule.indent(indent_level)}try:  # option {i + 1}"
            ret += f"{Rule.indent(indent_level + 1)}{Rule.paths(paths_level + 2)} = {Rule.paths(paths_level)}"
            ret += arg(indent_level + 1, paths_level + 2)
            ret += f"{Rule.indent(indent_level + 1)}{Rule.paths(paths_level + 1)} |= {Rule.paths(paths_level + 2)}"
            ret += f"{Rule.indent(indent_level)}except CompilerSyntaxError:"
            ret += f"{Rule.indent(indent_level + 1)}pass"

        ret += "\n"
        ret += f"{Rule.indent(indent_level)}if len({Rule.paths(paths_level + 1)}) == 0:"
        ret += f"{Rule.indent(indent_level + 1)}raise CompilerSyntaxError(self)"
        ret += "\n"
        ret += f"{Rule.indent(indent_level)}{Rule.paths(paths_level)} = {Rule.paths(paths_level + 1)}"
        ret += f"{Rule.indent(indent_level)}# end oneof"
        ret += "\n"
        return ret


class Term(Rule):
    def __init__(self, arg: str):
        self.arg: str = arg

    def __call__(self, indent_level: int, paths_level: int) -> str:
        return f"{Rule.indent(indent_level)}{Rule.paths(paths_level)} = self.process_paths({Rule.paths(paths_level)}, {self.arg})"


class ProductionTemplate:
    rule: RuleTemplate = ()

    @classmethod
    def generate(cls) -> str:
        if isinstance(cls.rule, Switch) and not cls.rule.enabled:
            return ""

        rule = Rule.get(cls.rule)

        if not isinstance(rule, Term) and len(rule.args.args if
                                              isinstance(rule.args, Group) else
                                              rule.args) == 0:
            return ""

        ret = f"class {cls.__name__}(Production):"
        ret += f"{Rule.indent(1)}def __init__(self, parent: Optional[Production], lexer: \"Lexer\"):"
        ret += f"{Rule.indent(2)}super().__init__(parent, lexer)"
        ret += f"{Rule.indent(2)}{Rule.paths(0)} = {{lexer.get_state()}}"
        ret += rule(2, 0).replace("\n\n\n", "\n\n")
        ret += f"{Rule.indent(2)}self.paths: set[\"Terminal\"] = {Rule.paths(0)}"
        return ret
