# This file is part of the Alchemist front-end libraries
# Copyright (C) 2023  Natan Junges <natanajunges@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# The code generated by this library is also under the GNU General Public
# License.
#
# The documentation generated by this library is not required by this
# library to be under any specific license.

from typing import Union, TypeVar, Generic

_RuleTemplate = Union["_RuleTemplates", "_Rule", str]
_RuleTemplates = tuple[_RuleTemplate, ...] | list[_RuleTemplate]
_T = TypeVar("_T", list["_Rule"], "_Group", str)
Terminals = dict[str, str | None]


class _Rule(Generic[_T]):
    @staticmethod
    def get(template: _RuleTemplate) -> "_Rule":
        if isinstance(template, tuple):
            return _Group(template)

        if isinstance(template, list):
            return _Optional(template)

        if isinstance(template, str):
            return _Symbol(template)

        return template

    @staticmethod
    def _filter(rules: list["_Rule"]) -> list["_Rule"]:
        filtered_rules: list[_Rule] = [rule for rule in rules if not isinstance(rule, Switch) or rule.enabled]
        filtered_rules = [
            rule for rule in filtered_rules
            if isinstance(rule, _Symbol)
            or len(rule.filtered_rules.filtered_rules if isinstance(rule.filtered_rules, _Group) else rule.filtered_rules) > 0
        ]
        return filtered_rules

    def __init__(self, rules: _T) -> None:
        self.rules: _T = rules
        self.filtered_rules: _T = rules

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        raise NotImplementedError()

    def md(self, terminals: Terminals) -> str:  # pylint: disable=invalid-name
        raise NotImplementedError()


class _Group(_Rule[list[_Rule]]):
    def __init__(self, templates: _RuleTemplates) -> None:
        super().__init__([_Rule.get(template) for template in templates])
        self.filtered_rules = self._filter(self.rules)
        i: int = 0

        while i < len(self.filtered_rules):
            if isinstance(self.filtered_rules[i], _Group):
                rules: list[_Rule] = self.filtered_rules[i].filtered_rules
                self.filtered_rules = self.filtered_rules[:i] + rules + self.filtered_rules[i + 1:]
                i += len(rules)
            else:
                i += 1

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        code: str = ""

        for rule in self.filtered_rules:
            code += rule(indent, level, ambiguous)

        return code

    def md(self, terminals: Terminals) -> str:
        code: str = ""
        first: bool = True

        for rule in self.rules:
            code += f'{" " if not first else ""}{rule.md(terminals)}'

            if first:
                first = False

        return code


class _Optional(_Rule[_Group]):
    def __init__(self, templates: list[_RuleTemplate]) -> None:
        super().__init__(_Group(templates))

        if len(self.filtered_rules.filtered_rules) == 1 and isinstance(self.filtered_rules.filtered_rules[0], _Optional):
            self.filtered_rules = self.filtered_rules.filtered_rules[0].filtered_rules

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        code: str = "\n"
        code += f"\n{'    ' * indent}try:  # optional"
        code += f"\n{'    ' * (indent + 1)}paths{level + 1} = paths{level}"
        code += self.rules(indent + 1, level + 1, ambiguous)

        if ambiguous:
            code += f"\n{'    ' * (indent + 1)}GraphNode.merge_paths(paths{level}, paths{level + 1})"
        else:
            code += f"\n{'    ' * (indent + 1)}paths{level} = paths{level + 1}"

        code += f"\n{'    ' * indent}except (CompilerSyntaxError, CompilerEOIError):"
        code += f"\n{'    ' * (indent + 1)}pass"
        code += "\n"
        return code

    def md(self, terminals: Terminals) -> str:
        if len(self.rules.rules) == 1 and isinstance(self.rules.rules[0], oneof):
            return f"_[_{self.rules.rules[0].md(terminals, False, False)}_]_"

        return f"_[_{self.rules.md(terminals)}_]_"


class Switch(_Rule[_Group]):
    enabled: bool = False

    def __init__(self, *templates: _RuleTemplate) -> None:
        super().__init__(_Group(templates))

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        return self.rules(indent, level, ambiguous)

    def md(self, terminals: Terminals) -> str:
        return f"<code>{self.rules.md(terminals)}</code>[^{self.__class__.__name__}]"


class repeat(_Rule[_Group]):  # pylint: disable=invalid-name
    def __init__(self, *templates: _RuleTemplate) -> None:
        super().__init__(_Group(templates))

        if len(self.filtered_rules.filtered_rules) == 1 and isinstance(self.filtered_rules.filtered_rules[0], repeat):
            self.filtered_rules = self.filtered_rules.filtered_rules[0].filtered_rules

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        code: str = "\n"
        code += f"\n{'    ' * indent}paths{level + 1} = paths{level}"
        code += "\n"
        code += f"\n{'    ' * indent}while True:  # repeat"
        code += f"\n{'    ' * (indent + 1)}try:"
        code += self.rules(indent + 2, level + 1, ambiguous)

        if ambiguous:
            code += f"\n{'    ' * (indent + 2)}GraphNode.merge_paths(paths{level}, paths{level + 1})"
        else:
            code += f"\n{'    ' * (indent + 2)}paths{level} = paths{level + 1}"

        code += f"\n{'    ' * (indent + 1)}except (CompilerSyntaxError, CompilerEOIError):"
        code += f"\n{'    ' * (indent + 2)}break"
        code += "\n"
        return code

    def md(self, terminals: Terminals) -> str:
        if len(self.rules.rules) == 1 and isinstance(self.rules.rules[0], oneof):
            return f"_{{_{self.rules.rules[0].md(terminals, False, False)}_}}_"

        return f"_{{_{self.rules.md(terminals)}_}}_"


class oneof(_Rule[list[_Rule]]):  # pylint: disable=invalid-name
    def __init__(self, *templates: _RuleTemplate) -> None:
        super().__init__([_Rule.get(template) for template in templates])
        self.filtered_rules = self._filter(self.rules)
        i: int = 0

        while i < len(self.filtered_rules):
            if isinstance(self.filtered_rules[i], oneof):
                rules: list[_Rule] = self.filtered_rules[i].filtered_rules
                self.filtered_rules = self.filtered_rules[:i] + rules + self.filtered_rules[i + 1:]
                i += len(rules)
            else:
                i += 1

    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        if len(self.filtered_rules) == 1:
            return self.filtered_rules[0](indent, level, ambiguous)

        code: str = "\n"
        code += f"\n{'    ' * indent}# begin oneof"
        code += f"\n{'    ' * indent}paths{level + 1}: Paths = {{}}"

        if not ambiguous:
            code += "\n"
            code += f"\n{'    ' * indent}with suppress(BreakException):"

        for i, rule in enumerate(self.filtered_rules):
            code += "\n"
            code += f"\n{'    ' * (indent + int(not ambiguous))}try:  # option {i + 1}"
            code += f"\n{'    ' * (indent + 1 + int(not ambiguous))}paths{level + 2} = paths{level}"
            code += rule(indent + 1 + int(not ambiguous), level + 2, ambiguous)

            if ambiguous:
                code += f"\n{'    ' * (indent + 1)}GraphNode.merge_paths(paths{level + 1}, paths{level + 2})"
            else:
                code += f"\n{'    ' * (indent + 2)}paths{level + 1} = paths{level + 2}"

            if not ambiguous:
                code += f"\n{'    ' * (indent + 2)}assert len(paths{level + 1}) != 0"
                code += f"\n{'    ' * (indent + 2)}raise BreakException()"

            code += (
                f"\n{'    ' * (indent + int(not ambiguous))}except (CompilerSyntaxError, CompilerEOIError{'' if ambiguous else ', AssertionError'}):"
            )
            code += f"\n{'    ' * (indent + 1 + int(not ambiguous))}pass"

        code += "\n"

        if ambiguous:
            code += f"\n{'    ' * indent}if len(paths{level + 1}) == 0:"

        code += f"\n{'    ' * (indent + 1)}raise CompilerNoPathError(self)"
        code += "\n"
        code += f"\n{'    ' * indent}paths{level} = paths{level + 1}"
        code += f"\n{'    ' * indent}# end oneof"
        code += "\n"
        return code

    def md(self, terminals: Terminals, top: bool = False, paren: bool = True) -> str:
        code: str = ""
        first: bool = True
        one_of: bool = top and all(isinstance(rule, _Symbol) for rule in self.rules)
        separator: str = (" " if one_of else "  \n&emsp;&emsp;") if top else " _|_ "

        if one_of:
            code += "_(one of)_  \n&emsp;&emsp;"

        if not top and paren:
            code += "_(_"

        for rule in self.rules:
            code += f'{separator if not first else ""}{rule.md(terminals)}'

            if first:
                first = False

        if not top and paren:
            code += "_)_"

        return code


class _Symbol(_Rule[str]):
    def __call__(self, indent: int, level: int, ambiguous: bool) -> str:
        return f"\n{'    ' * indent}paths{level} = self._process_paths(paths{level}, {self.rules})"

    def md(self, terminals: Terminals) -> str:
        if self.rules in terminals:
            if terminals[self.rules] is None:
                return "_{}_".format(self.rules.replace("_", "\\_"))

            return "**{}**".format(terminals[self.rules].replace("_", "\\_").replace("*", "\\*"))  # type: ignore[union-attr]

        return "_[{}](#{})_".format(self.rules.replace("_", "\\_"), self.rules)


class ProductionTemplate:
    _template: _RuleTemplate = ()
    _left_recursive: bool = True
    _ambiguous: bool = True

    @classmethod
    def generate(cls) -> str:
        if isinstance(cls._template, Switch) and not cls._template.enabled:  # pylint: disable=no-member
            return ""

        rule: _Rule = _Rule.get(cls._template)

        if (
            not isinstance(rule, _Symbol)
            and len(rule.filtered_rules.filtered_rules if isinstance(rule.filtered_rules, _Group) else rule.filtered_rules) == 0
        ):
            return ""

        code: str = f"class {cls.__name__}(Production):"

        if not cls._left_recursive:
            code += "\n    _left_recursive = False"
            code += "\n"

        code += "\n    def _derive(self) -> None:"
        code += "\n        input_path = cast(GraphNode, self.input_path)"
        code += '\n        paths0: Paths = {cast("Terminal", input_path.path): {input_path}}'
        code += rule(2, 0, cls._ambiguous).replace("\n\n\n", "\n\n")
        code += "\n        self.output_paths = paths0"
        return code

    @classmethod
    def generate_md(cls, level: int, terminals: Terminals, link: str | None = None) -> str:
        terminals = terminals | {cls.__name__: None}
        rule: _Rule = _Rule.get(cls._template)
        code: str

        if link is not None:
            code = "{} [{}]({}#{}):".format("#" * level, cls.__name__.replace("_", "\\_"), link, cls.__name__)
        else:
            code = "{} {}:".format("#" * level, cls.__name__.replace("_", "\\_"))

        code += "\n&emsp;&emsp;{}  ".format(  # pylint: disable=consider-using-f-string
            # pylint: disable-next=too-many-function-args
            (rule.md(terminals, True) if isinstance(rule, oneof) else rule.md(terminals)).replace("__", "").replace("_ _", " ").replace("** **", " ")
        )

        return code
